里斯替换原则
我们都知道面向对象有三大特性：封装、继承、多态。所以我们在实际开发过程中，子类在继承父类后，根据多态的特性，可能是图一时方便，经常任意重写父类的方法，那么这种方式会大大增加代码出问题的几率。比如下面场景：类C实现了某项功能F1。现在需要对功能F1作修改扩展，将功能F1扩展为F，其中F由原有的功能F1和新功能F2组成。新功能F由类C的子类C1来完成，则子类C1在完成功能F的同时，有可能会导致类C的原功能F1发生故障。这时候里氏替换原则就闪亮登场了。
什么是里氏替换原则
前面说过的单一职责原则，从字面意思就很好理解，但是里氏替换原则就有点让人摸不着头脑。查过资料后发现原来这项原则最早是在1988年，由麻省理工学院一位姓里的女士（Liskov）提出来的。英文缩写：LSP (Liskov Substitution Principle)。

严格的定义：如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。

通俗的定义：所有引用基类的地方必须能透明地使用其子类的对象。

更通俗的定义：子类可以扩展父类的功能，但不能改变父类原有的功能。

四层含义
里氏替换原则包含以下4层含义：
	子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
	子类中可以增加自己特有的方法。
	当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
	当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

几个名词解释
抽象类：含有一个或多个抽象方法的类称为抽象类，在声明时，类名前须添加"abstract"关键字。注：抽象类中可以包含非抽象方法
抽象方法：只包含方法定义，没有具体实现的方法，需要其子类或者子类的子类来具体实现。


静态方法不能标记为 override、virtual 或 abstract,即静态方法都必须是具体的。

抽象类不能够被实例化，这是因为它包含了没有具体实现的方法，即可实例化的类一定不是抽象类，不包含未具体实现的抽象方法。

子类继承抽象父类后，可以使用override关键字覆盖父类中的抽象方法，并做具体的实现。也可以不实现抽象方法，留给后代实现，这时子类仍旧是一个抽象类，必须声明为abstract

隐藏：在子类中创建与父类中的方法具有相同签名（相同的方法名，相同的参数列表--参数类型和次序）的方法(可以带有"virtual"或"override"关键字)即可实现，但建议使用"new"关键字,以明确地隐藏。

只能使用"override"关键字来覆盖(override)父类中标记为"virtual"、"abstract"或"override"的方法,而子类中标记为override的方法，也必须是父类中标记为"virtual"、"abstract"或"override"的方法。

覆盖(override):必须使用override关键字，可以被覆盖的方法包括标记为abstract,virtual,和override的方法；

隐藏:使用new关键字，也可不使用关键字，可以被隐藏的方法包括一般方法，和标记为virtual"或"override"的方法；

重载(overload)：不需要任何特殊的关键字

静态方法可以被隐藏或重载



